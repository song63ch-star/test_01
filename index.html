<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>스네이크 게임 (HTML 단일 파일)</title>
  <style>
    :root {
      --bg: #0f1222;
      --panel: #171a2e;
      --text: #e8ecf1;
      --muted: #9aa6b2;
      --accent: #6ce37b;
      --accent-dark: #2fb153;
      --danger: #ff5a63;
      --grid: #212642;
      --snake: #7ad0ff;
      --snake-head: #24a4ff;
      --food: #ff6f61;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(100% 100% at 50% 0%, #121531 0%, #0b0e1f 100%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", "맑은 고딕", Arial, sans-serif;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .card {
      width: min(92vw, 720px);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 20px 50px rgba(0,0,0,0.35);
      border-radius: 16px;
      padding: 18px 18px 22px;
      backdrop-filter: blur(6px);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }
    .title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: .2px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .title .dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px var(--accent);
    }

    .stats {
      display: flex;
      align-items: center;
      gap: 14px;
      color: var(--muted);
      font-weight: 600;
      font-size: 14px;
    }
    .stats strong {
      color: var(--text);
      margin-left: 6px;
      font-size: 16px;
    }

    .canvas-wrap {
      position: relative;
      background: linear-gradient(180deg, #0c1026, #0b0e21);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
      padding: 10px;
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      background:
        radial-gradient(circle at 30% 20%, rgba(108,227,123,0.06), transparent 40%),
        radial-gradient(circle at 70% 80%, rgba(36,164,255,0.06), transparent 40%),
        #0c1026;
      border-radius: 8px;
    }

    .footer {
      margin-top: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
      font-size: 14px;
      flex-wrap: wrap;
    }

    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0px) scale(0.98); }
    .primary {
      background: linear-gradient(180deg, var(--accent), var(--accent-dark));
      border-color: rgba(0,0,0,0.2);
      color: #07130a;
      text-shadow: 0 1px 0 rgba(255,255,255,0.3);
    }
    .danger {
      background: linear-gradient(180deg, rgba(255,90,99,0.9), rgba(255,90,99,0.7));
      border-color: rgba(0,0,0,0.2);
      color: #2a0507;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
    }

    .help {
      opacity: 0.9;
      line-height: 1.4;
    }
    kbd {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 12px;
      color: var(--text);
    }

    /* 반응형: 캔버스 컨테이너 최대폭 조정 */
    .canvas-wrap { width: 100%; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="title"><span class="dot"></span> 스네이크 게임</div>
        <div class="stats">
          점수 <strong id="score">0</strong>
          <span>／</span>
          최고 <strong id="best">0</strong>
          <span style="margin-left:10px;color:#6ce37b" id="stateLabel"></span>
        </div>
      </div>

      <div class="canvas-wrap">
        <!-- 논리 해상도(픽셀)는 고정, CSS로 폭에 맞춰 스케일 -->
        <canvas id="game" width="600" height="600" aria-label="스네이크 게임 캔버스" role="img"></canvas>
      </div>

      <div class="footer">
        <div class="help">
          <strong>조작:</strong>
          <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> 이동 ·
          <kbd>Space</kbd> 일시정지/재개 ·
          <kbd>R</kbd> 재시작
        </div>
        <div class="buttons">
          <button class="primary" id="btnStart">시작/재개</button>
          <button id="btnPause">일시정지</button>
          <button class="danger" id="btnRestart">재시작</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===============================
    // 스네이크 게임 - 단일 파일 버전
    // by M365 Copilot
    // ===============================

    // ---- 기본 설정 ----
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // 논리 그리드 크기 (GRID x GRID)
    const GRID = 25;         // 25x25 그리드
    const TILE = canvas.width / GRID; // 타일 픽셀 크기
    const TICK_MS = 120;     // 속도(틱 주기, ms)
    const BORDER = 0;        // 타일 테두리(시각 강조용), 0~4 정도

    // 색상
    const COLOR = {
      bg: '#0c1026',
      grid: 'rgba(255,255,255,0.06)',
      snake: '#7ad0ff',
      snakeHead: '#24a4ff',
      food: '#ff6f61',
      wall: '#212642',
    };

    // UI 엘리먼트
    const $score = document.getElementById('score');
    const $best = document.getElementById('best');
    const $stateLabel = document.getElementById('stateLabel');
    const $btnStart = document.getElementById('btnStart');
    const $btnPause = document.getElementById('btnPause');
    const $btnRestart = document.getElementById('btnRestart');

    // 게임 상태
    const STATE = { READY: 'READY', RUNNING: 'RUNNING', PAUSED: 'PAUSED', OVER: 'GAME OVER' };
    let state = STATE.READY;

    // 스네이크, 음식, 방향
    let snake, dir, nextDir, food, score, best;
    let inputLocked = false;     // 틱당 1회 입력만 허용
    let lastTime = 0, acc = 0;   // 타이머

    // 최고 점수 로드
    best = Number(localStorage.getItem('snake_best') || 0);
    $best.textContent = best;

    // ----- 유틸 -----
    function randInt(min, max) { // [min, max]
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function same(a, b) { return a.x === b.x && a.y === b.y; }

    // 빈 칸 중 랜덤 위치 반환 (스네이크 몸통과 겹치지 않도록)
    function randomFreeCell() {
      // 간단 구현: 무한 루프 가드 포함
      for (let i = 0; i < 1000; i++) {
        const p = { x: randInt(0, GRID - 1), y: randInt(0, GRID - 1) };
        if (!snake.some(s => same(s, p))) return p;
      }
      // 거의 꽉 찼다면 fallback
      return { x: 0, y: 0 };
    }

    function resetGame() {
      const mid = Math.floor(GRID / 2);
      snake = [
        { x: mid,     y: mid },
        { x: mid - 1, y: mid },
        { x: mid - 2, y: mid },
      ];
      dir = { x: 1, y: 0 };     // 오른쪽 시작
      nextDir = { ...dir };
      food = randomFreeCell();
      score = 0;
      $score.textContent = score;
      state = STATE.READY;
      $stateLabel.textContent = '준비됨';
      acc = 0;
      lastTime = 0;
      inputLocked = false;
      draw(); // 초기 화면
    }

    // ----- 입력 처리 -----
    function setDirection(nx, ny) {
      // 반대 방향 즉시 전환 방지 (길이가 2 이상일 때 의미)
      if (snake.length > 1 && nx === -dir.x && ny === -dir.y) return;
      if (inputLocked) {
        // 이미 이번 틱에 입력 반영됨 -> 큐잉(한 번만)
        // nextDir 기준으로도 반대 판정 방지
        if (snake.length > 1 && nx === -nextDir.x && ny === -nextDir.y) return;
        nextDir = { x: nx, y: ny };
        return;
      }
      nextDir = { x: nx, y: ny };
      inputLocked = true; // 틱에서 해제
    }

    window.addEventListener('keydown', (e) => {
      // 화살표 기본 스크롤 방지
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key) || e.key.toLowerCase() === 'r') {
        e.preventDefault();
      }
      switch (e.key) {
        case 'ArrowUp':    setDirection(0, -1); break;
        case 'ArrowDown':  setDirection(0, 1);  break;
        case 'ArrowLeft':  setDirection(-1, 0); break;
        case 'ArrowRight': setDirection(1, 0);  break;
        case ' ': // Space: pause/resume
          if (state === STATE.RUNNING) pauseGame();
          else if (state === STATE.PAUSED || state === STATE.READY) startGame();
          break;
        case 'r':
        case 'R':
          resetGame();
          startGame();
          break;
      }
    });

    $btnStart.addEventListener('click', () => {
      if (state === STATE.RUNNING) return;
      startGame();
    });
    $btnPause.addEventListener('click', () => {
      if (state === STATE.RUNNING) pauseGame();
    });
    $btnRestart.addEventListener('click', () => {
      resetGame();
      startGame();
    });

    // ----- 게임 루프 -----
    function startGame() {
      if (state === STATE.OVER) resetGame();
      state = STATE.RUNNING;
      $stateLabel.textContent = '플레이 중';
      lastTime = performance.now();
      acc = 0;
      requestAnimationFrame(loop);
    }

    function pauseGame() {
      if (state !== STATE.RUNNING) return;
      state = STATE.PAUSED;
      $stateLabel.textContent = '일시정지';
      // loop는 상태 확인하므로 그냥 중단됨
    }

    function gameOver() {
      state = STATE.OVER;
      $stateLabel.textContent = '게임 오버';
      // 최고 점수 저장
      if (score > best) {
        best = score;
        localStorage.setItem('snake_best', String(best));
        $best.textContent = best;
      }
      draw(); // 오버 화면 그리기
    }

    function loop(now) {
      if (state !== STATE.RUNNING) {
        draw();
        return;
      }
      const dt = now - lastTime;
      lastTime = now;
      acc += dt;

      // 고정 틱 처리
      while (acc >= TICK_MS) {
        tick();
        acc -= TICK_MS;
      }

      draw();
      requestAnimationFrame(loop);
    }

    function tick() {
      // 입력 확정
      dir = { ...nextDir };

      // 머리 이동
      const head = snake[0];
      const newHead = { x: head.x + dir.x, y: head.y + dir.y };

      // 벽 충돌
      if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID) {
        gameOver();
        inputLocked = false;
        return;
      }

      // 자기 몸 충돌 (꼬리 자를 예정이라도 먼저 검사)
      if (snake.some(seg => same(seg, newHead))) {
        gameOver();
        inputLocked = false;
        return;
      }

      // 이동 & 먹이 처리
      snake.unshift(newHead);
      if (same(newHead, food)) {
        // 먹이 먹음: 점수 +1, 꼬리 유지(길이 증가)
        score += 1;
        $score.textContent = score;
        // 새 먹이
        food = randomFreeCell();
      } else {
        // 일반 이동: 꼬리 제거
        snake.pop();
      }

      // 다음 틱을 위한 입력 언락
      inputLocked = false;
    }

    // ----- 렌더링 -----
    function drawGrid() {
      ctx.strokeStyle = COLOR.grid;
      ctx.lineWidth = 1;

      ctx.beginPath();
      for (let i = 1; i < GRID; i++) {
        const x = Math.floor(i * TILE) + 0.5;
        const y = Math.floor(i * TILE) + 0.5;
        // 세로선
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        // 가로선
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
      }
      ctx.stroke();
    }

    function drawCell(x, y, color, isHead = false) {
      const px = x * TILE;
      const py = y * TILE;
      const inset = Math.max(0, BORDER);
      const r = Math.max(4, Math.min(TILE / 3, 8)); // 둥근 모서리

      ctx.fillStyle = color;
      roundRect(ctx, px + inset, py + inset, TILE - inset * 2, TILE - inset * 2, isHead ? r : r - 2);
      ctx.fill();

      // 은은한 하이라이트
      if (isHead) {
        const grad = ctx.createRadialGradient(px + TILE*0.35, py + TILE*0.35, 2, px + TILE*0.35, py + TILE*0.35, TILE*0.7);
        grad.addColorStop(0, 'rgba(255,255,255,0.22)');
        grad.addColorStop(1, 'rgba(255,255,255,0.0)');
        ctx.fillStyle = grad;
        roundRect(ctx, px + inset, py + inset, TILE - inset * 2, TILE - inset * 2, r);
        ctx.fill();
      }
    }

    function drawFood(x, y) {
      const cx = x * TILE + TILE / 2;
      const cy = y * TILE + TILE / 2;
      const radius = TILE * 0.38;

      const grad = ctx.createRadialGradient(cx - radius/3, cy - radius/3, 2, cx, cy, radius);
      grad.addColorStop(0, '#ff9b91');
      grad.addColorStop(1, COLOR.food);

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();

      // 반짝 포인트
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath();
      ctx.arc(cx - radius/2.2, cy - radius/2.2, radius/6, 0, Math.PI * 2);
      ctx.fill();
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawOverlay(text, sub) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';

      ctx.font = '700 36px "Segoe UI", "Noto Sans KR", Arial, sans-serif';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2 - 8);

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '500 16px "Segoe UI", "Noto Sans KR", Arial, sans-serif';
      ctx.fillText(sub, canvas.width / 2, canvas.height / 2 + 22);
    }

    function draw() {
      // 배경
      ctx.fillStyle = COLOR.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 그리드
      drawGrid();

      // 음식
      if (food) drawFood(food.x, food.y);

      // 스네이크
      if (snake && snake.length) {
        // 몸통
        for (let i = snake.length - 1; i >= 1; i--) {
          drawCell(snake[i].x, snake[i].y, COLOR.snake, false);
        }
        // 머리
        const head = snake[0];
        drawCell(head.x, head.y, COLOR.snakeHead, true);
      }

      // 상태 오버레이
      if (state === STATE.READY) {
        drawOverlay('시작하려면 Space 또는 시작 버튼', '화살표 키로 방향을 조작하세요');
      } else if (state === STATE.PAUSED) {
        drawOverlay('일시정지', 'Space: 재개 · R: 재시작');
      } else if (state === STATE.OVER) {
        drawOverlay('게임 오버', 'R: 재시작 · Space: 다시 시작');
      }
    }

    // 초기화 후 첫 화면 렌더
    resetGame();
  </script>
</body>
</html>
